Lo scopo delle simulazioni di attacco e random failure nei confronti delle reti in analisi è condurre uno studio approfondito sulle loro grandezze statistiche e topologiche, e in particolar modo sul loro andamento sotto caduta random o mirata dei nodi.  
Con questo intento, inizialmente è stata utilizzata *networkx*, una libreria di Python dedicata alle reti piuttosto completa. Tuttavia questa si è rivelata una scelta sbagliata, in quanto networkx non si è rivelata essere ben costruita: mentre le funzioni di generazione e manipolazione delle reti, e estrapolazione dei gradi dei nodi siano, molto veloci, quando si vanno a usare le funzioni più pesanti dal punto di vista del calcolo, come per esempio quella per determinare il diametro della rete, networkx appare non soddisfacente.  
Per esempio, solo la prima analisi sulle grandezze $D$, $\langle l \rangle$ e $C$ impiegava solo con la rete Tre (la più piccola, $\sim1400$ nodi) 20 secondi e con la rete Wind (la più grande con $\simTODO$ nodi) impiega ben 2.5 minuti, con una previsione di ore di calcolo per la progressiva distruzione e analisi percolativa delle reti piccole, e tempi esponenzialmente più grandi per lo studio della rete complessiva. La prima soluzione a questo problema è tentare una parallelizzazione del codice. Dato che networkx non supporta il calcolo parallelo, si è tentato di parallelizzare le funzioni di attacco e random failure. Tuttavia, è impossibile mappare le funzioni di rimozione nodi con il metodo sequenziale che è stato scelto: per l'iterazione successiva è necessario avere la rete nuova senza i nodi dell'iterazione precedente. 
Un possibile metodo per ovviare a ciò sarebbe potuto essere calcolare e salvare in memoria tutte le reti a tutte le iterazioni e successivamente usare delle funzioni parallelizzabili per l'analisi. Tuttavia con networkx la richiesta di tempo di calcolo rimarrebbe comunque alta e al problema della potenza di calcolo si aggiungerebbe quello della memoria.
L'unica via praticabile è stata ripiegare su un altra libreria, meno user friendly ma estremamente più efficiente e veloce, e sopratutto impostata di default sul calcolo parallelo. Non solo le funzioni di analisi topologica e statistica sono molto più veloci di per se, ma con la possibilità di inviarle in parallelo ci ha permesso di fare calcoli 60 volte più velocemente con le singole funzioni. 